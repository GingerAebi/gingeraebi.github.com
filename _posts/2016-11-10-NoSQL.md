---
layout: post
title: Database 종류와 분석 - NoSQL

---

# NoSQL

이번 포스트에서는 NoSQL에 대한 탐험을 시작해보도록 하겠다. NoSQL 이놈은 대체 뭐길래 뜬금없이 등장해서 프로그래머들을 괴롭히는 것일까? 필자가 처음 프로그래밍을 시작할 때즈음 (2014년정도) 부터 소문이 돌기 시작하더니 이제는 너무나 많이들 사용하는 대중적인 데이터베이스 포맷이 되어버렸다. 

필자가 처음 NoSQL로 접했던 DB는 MongoDB였다. Node.js를 필두로 한 MEAN스택에서부터 스멀스멀 보이기 시작하더니 나중에 가서는 한번쯤은 다들 써본? 그런 존재가 되어있었다. 

![](https://i.ytimg.com/vi/Jh0er2pRcq8/maxresdefault.jpg =600x)

필자가 한번 써볼까? 라는 생각이 들었던 것은 그 때 즈음이었던 것 같다. 사실상 안드로이드 공부에만 집중하고 있었던 나에게는 MEAN스택 자체가 '아 웹쪽 세상에서 일어나는 무언가인가보다' 정도로만 생각되고 그렇게 큰 관심을 두고 있지 않았던 것이 사실이었다.

하지만 역시 호기심이 드는 것은 어쩔 수 없었던것 같다. 안드로이드 개발을 하면서 서버 개발도 같이 해야되는 상황이 생겼었고 기억 저 한켠에 묻어두었던 MEAN스택을 꺼내들었다. 처음에는 Node.js만 공부해 볼 생각으로 접하게 되었고, 하다보니 아 그러면 NoSQL인 MongoDB도 한번 써볼까? 라는 생각까지 미치게 되었다. 

간단한 API서버만 만들면 되는 상황이었고 JSON 형식으로 통신을 할 생각을 하고 있었기 때문에 NoSQL이 JSON데이터를 날로 저장하고 꺼낼 수 있다는 지식 하나만으로 '한번 해보자'라는 생각을 하게 되었던 것 같다. 

하지만 점차 써감에 있어서 여러 문제들이 (예를 들면 데이터 두개를 섞어서 가져오고 싶다던가) 발생하게 되었고, RDBMS에 너무 익숙해져 있던 것일까 NoSQL의 사용을 포기하는 시점에 다다르게 되었었다.

그 이후로 NoSQL과는 인연을 끊고 살다가 이제 회사에 들어와 어쩔 수 없이 이 친구를 마주봐야 하는 상황에 처하게 되었다. 이왕 이렇게 된거 제대로 알아보고 써보자는 생각이 들었고 앞으로 이 포스팅을 통해서 제!대!로!(제발...) NoSQL의 종류와 특징을 알아보도록 하겠다. 

## NoSQL이란?
나무 위키에 매우 자세하고 이해하기 쉽게 정리되어 있기에 그대로 들고와 필자의 사견을 살짝만 첨가하도록 하겠다. 

[https://namu.wiki/w/NoSQL](https://namu.wiki/w/NoSQL)

### 1. 개요

단어 뜻 그 자체를 따지자면 "Not only SQL"로, SQL만을 사용하지 않는 데이터베이스 관리 시스템(DBMS)을 지칭하는 단어이다. 관계형 데이터베이스를 사용하지 않는다는 의미가 아닌, 여러 유형의 데이터베이스를 사용하는 것이다.

데이터를 조직하는 방법에는 리스트, 해시, 트리, 그래프 등의 다양한 방법이 있고 각각은 장점과 단점이 명확하기 때문에 단순히 NoSQL 이라고만 해서는 너무 뜬구름 잡는 얘기가 된다. 저 단어는 RDBMS가 데이터베이스의 거의 전부를 차지할 정도로 독점적인 지위를 차지하고 있는 현재 상황에 반발하는 정신을 담고 있다.

*지금까지 필자는 NoSQL이라고 하면 뭔가 자유롭게 데이터를 저장하고 Json이거나 문자열이거나 넣고싶은 모양 '그대로' 넣었다가 '그대로' 꺼내서 사용하는 형태를 생각했었다. 아래에서도 나오겠지만 이런 생각은 틀린 생각이었다는 것을 알게되었다. 이제는 NoSQL은 RDBMS와 같이 어떠한 형태를 딱 지정해서 말하는 것이 아니라 RDBMS가 아닌 모든 것을 총칭해 말하는 것이라고 느껴진다.*

### 2. 정의 

“Not Only SQL” : 데이터를 저장하는 데에는 SQL 외에 다른 방법들도 있다.

NoSQL이라고 하는 말은 No 'English' 라고 하는 말과 마찬가지다. 세상에는 영어 말고도 수많은 언어가 존재한다. MongoDB에서 사용하는 쿼리 언어와 CouchDB에서 사용하는 쿼리 언어는 서로 전혀 다르다. 그럼에도 이 두 쿼리 언어는 같은 NoSQL 카테고리에 속한다. 어쨌거나 SQL이 아니기 때문이다. 또한 NoSQL이 No RDBMS를 의미하지는 않는다. BerkleyDB같은 예외가 있기 때문이다. 그리고 No RDMBS가 NoSQL인 것도 아니다. SQL호환 레이어를 제공하는 KV-store라는 예외가 역시 존재한다. 물론 KV-store의 특징상 range query를 where절에 넣을 수 없으므로 완전한 SQL은 못 되고 SQL의 부분집합 정도를 제공한다.

사실 아직까지 NoSQL에 내려진 **구체적인 정의는 없다**. 하지만 NoSQL이라 불리는 데이터베이스들은 대체로 다음과 같은 공통적인 성향을 보인다.

- 대부분 클러스터에서 실행할 목적으로 만들어졌기 때문에 **관계형 모델을 사용하지 않는다.** 그러나 모든 NoSQL 데이터베이스가 클러스터에서 실행되도록 맞춰진 것은 아니다. 예를 들어 NoSQL 데이터 모델 중 하나인 그래프 데이터베이스는 관계형 데이터베이스와 비슷한 분산 모델을 사용한다.
- **오픈 소스**이다. 비오픈 소스 프로젝트도 있긴 하지만, 대부분 그렇다.
- 보통 21세기 초반 웹 환경의 필요에 기초를 두고 있어서, 이 시기에 개발된 시스템만을 NoSQL이라고 부른다. 따라서 그 이전에 만들어진 ODBMS(Objective Database Management System)은 NoSQL에 해당하지 않는다.
- **스키마 없이 동작**하며, 구조에 대한 정의를 변경할 필요 없이 데이터베이스 레코드에 자유롭게 필드를 추가할 수 있다.  

````
요약 : 대부분이 오픈 소스고, 21세기 초반에 개발되었으며
SQL을 사용하지 않는 Schema-less 데이터베이스.
````

### 3. 등장 배경 

지난 20년간, 데이터를 저장하는 데에는 관계형 데이터베이스가 사용되었다. **트랜잭션을 통한 안정적인 데이터 관리**가 가장 중요한 이슈였기 때문이다. 하지만 웹 2.0 환경과 빅데이터가 등장하면서 RDBMS는 난관에 부딪히게 되었는데, 바로 *‘데이터를 처리하는 데 필요한 비용의 증가’*때문이다. 데이터와 트래픽의 양이 기하급수적으로 증가함에 따라 한 대에서 실행되도록 설계된 관계형 데이터베이스를 사용하는 것은 하드웨어적으로 큰 비용이 들게 되었다. 장비의 성능이 좋을수록, 성능을 향상시키는 데(Scale-up : 수직적 확장) 비용이 기하급수적으로 증가하기 때문이다.

NoSQL은 데이터의 일관성을 약간 포기한 대신 여러 대의 컴퓨터에 데이터를 분산하여 저장하는 것**(Scale-out : 수평적 확장)**을 목표로 등장하였다. NoSQL의 등장으로 작고 값싼 장비 여러 대로 대량의 데이터와 컴퓨팅 부하를 처리하는 것이 가능하게 되었다.

*결국 모든것은 비용으로 귀결되는것 같다. 프로그래밍이야 말로 비용을 줄이기 위한 노력의 결정체이지 않을까?*  
*처음 NoSQL에 대한 얘기를 들었을 때도 NoSQL은 데이터를 txt처럼 저장하기 떄문에 여러개의 컴퓨터에 나누어 저장해도 되는 느낌이라고 들었던 것 같다. 지금 생각해보면 정확히 그런 느낌은 아니겠지만, 그래도 어떤 말을 하려 했는지 조금은 이해가 가는 것 같다.*

### 4. 특징 

#### 4.1. 일관성과 확장성 사이의 Trade-off

일관성(Consistency)이 데이터베이스의 절대적인 요소가 아님을 주장하는 움직임이 생기기 시작했다. 이들은 비일관성이 다음과 같은 두 가지 이유로 감수할 만한 것이라고 주장했다.

- 다수가 동시에 읽고 쓰는(Read and write) 상황에서의 성능 향상을 위해서.
- 분산 환경에서 노드들이 잘 작동하고 있음에도, 시스템의 일부가 고장나면 데이터베이스를 사용할 수 없게 되는 문제를 해결하기 위해서.

*분산 환경의 얘기는 어떤 얘기인지 알 것 같은데 다수가 동시에 읽고 쓰는 것은 어떤 연관성이 있는지 헤깔린다. 추측을 해보자면 여러개의 파일로 데이터베이스를 관리하기 때문에 각 유저가 각각의 파일들을 잡고 여러개의 DB를 사용하는 느낌으로 쓴다는 것이 아닐까 싶다. 이는 아마 각각의 NoSQL의 종류에 따라서 다르지 않을까 라는 생각이 든다.* 

#### 4.2. 분산 저장

데이터와 트래픽이 증가함에 따라 기존의 장비로는 원할한 데이터의 처리가 어려워졌다. 이를 해결하기 위한 방법으로는 처리하는 장비의 성능을 키우는 **수직적 확장(Scale-up)**과 처리하는 장비의 수를 늘리는 **수평적 확장(Scale-out)**이 있다. 위에서 서술했듯이 수직적 확장은 비용적인 문제가 발생하므로 수평적 확장을 통해 성능을 올려야 한다. 하지만 문제는 관계형 데이터베이스가 클러스터 상에서 효율적으로 동작하도록 설계되지 않았다는 점이다. 

물론 관계형 데이터베이스를 클러스터 상에서 돌리지 못하는 것은 아니다. 클러스터 상에서 동작하는 관계형 데이터베이스 솔루션도 존재한다. 이러한 데이터베이스에서는 클러스터를 인식할 수 있는 파일 시스템을 사용해 고가용성 디스크 서브시스템에 데이터를 기록하는 공유 디스크 개념을 사용한다. 하지만 클러스터의 디스크 서브시스템이 단일 고장점이 되어, 디스크 서브시스템에 문제가 생길 경우 데이터베이스를 사용할 수 없게 된다.

샤딩(Sharding)은 샤드 키(Shard key)를 기준으로 하나의 테이블을 수평 분할하여 서로 다른 클러스터에 분산 저장하고 질의할 수 있는 기법이다. 이를 통해 관계형 데이터베이스에서도 부하를 분산할 수 있지만 어플리케이션 레벨에서 모든 샤딩을 제어해야 한다. (어떤 데이터를 어느 클러스터에서 처리해야 하는지 등) 또한 여러 샤드에 걸치는 쿼리나 참조 정합성, 트랜잭션, 일관성의 제어에 문제가 발생한다.

분산 저장을 지원하는 NoSQL 데이터베이스의 경우, **집합-지향(Aggregate-oriented) 모델**[^1]을 사용하여 이러한 문제를 해결한다. 연관된 데이터들이 함께 분산되므로, 관계형 모델에서처럼 복잡한 제어가 필요하지 않게 된다.


*결국 분산 저장을 하는 이유는 DB를 1개만 만들어두면 성능에 문제가 있기 때문이 아닐까 싶다. 많은 데이터를 저장해야 된다면 분산하여 저장하는 것도 나쁘지 않을 것으로 보인다. 반대로 데이터가 많지 않다면 굳이 분산저장을 안해도 된다고 느껴진다.*



#### 4.3. 데이터 일치

RDBMS에서 관계형 튜플 안의 값은 단순해야 하며 중첩된 레코드나 리스트 등 다른 구조를 포함할 수 없는 반면, 메모리 내 데이터 구조에서는 이런 제약이 없어 훨씬 복잡한 구조를 사용한다. (ex : 리스트, 딕셔너리, 중첩된 객체 구조) 그 결과 복잡한 메모리 내 데이터 구조를 데이터베이스에 저장하려면 먼저 관계형 표현으로 변환해야 한다. 물론 이는 ORM(Objective-Relational Mapping : 객체-관계 매핑) 프레임워크를 통해 해결할 수 있지만, 여전히 관계형 모델과 메모리 내 데이터 구조 간에는 데이터 불일치는 존재한다. 이를 Impedance mismatch라 한다.

하지만 NoSQL은 그런 게 없다. 메모리 내의 데이터가 어떤 구조이든지 상관하지 않고 하나의 Aggregation으로 취급하여 저장해버리기 때문이다. 따라서 NoSQL에서는 ORM 프레임워크가 필요하지 않다.

*음.. 메모리 내 데이터구조라는 것은 프로그래밍 할 때 데이터의 형식을 말하는 것 같다. 뭔가 메모리 내 데이터 구조라고 하니까 좀 이상해 보이지만, 코드상의 자료구조를 생각하면 될 것 같다. NoSQL에서는 모든 데이터를 하나의 집합으로 묶어서 저장한다고 생각하면 될 것 같다.*  

*여기서 데이터 일치라는 제목이 맞을지는 모르겠지만, 음 필자는 저런 네이밍 보다는 다양한 자료구조의 표현가능? 정도로 얘기하고 싶다. 데이터 일치라고 하면 뭔가 데이터의 일관성을 얘기하는거 같고 그래서..*

#### 4.4. Schema-less

NoSQL 데이터베이스의 공통적인 특징은 스키마 없이 동작한다는 점이다. 따라서 데이터 구조를 미리 정의할 필요가 없으며, 시간이 지나더라도 언제든지 바꿀 수 있기 때문에 비형식적인 데이터를 저장하는 데 용이하다. 하지만 이는 데이터베이스가 스키마를 직접 관리하지 않는 것을 의미할 뿐, 데이터 타입에 따른 암묵적인 스키마는 여전히 존재한다. 이 때문에 단일 값에 대한 데이터 타입에서 불일치가 발생할 수 있다. 

예를 들어 필드의 이름을 “Quantity”라고 하기로 했다고 하자. 이것은 앞으로 저장할 때 반드시 필드의 이름을 “Quantity”라고 저장하겠다는 암묵적인 스키마가 된다. 암묵적인 스키마를 무시할 경우 Quantity를 quantity, qty, QUANTITY 등으로 저장할지도 모른다. 뜬금없이 qty, quantity같은 새로운 필드가 추가되는 것이나 마찬가지이다. 이는 NoSQL 데이터베이스가 암묵적인 스키마에 대해 전혀 알지 못하며, 이를 강제하지 않기 때문에 발생하는 일이다. 그렇게 때문에 NoSQL을 사용할 때에는 주의를 기울일 필요가 있다.

*이는 정말로 주의할 필요가 있는것이, 실수로 오타를 내더라도 NoSQL에서는 에러 메세지를 뱉지를 않는다. 그래서 하나의 테이블을 두개 이상의 코드에서 사용하게 되면 데이터를 난 넣은거 같은데 왜 안나오지? 생각해서 삽질을 해본적이 종종 있다. 이는 NoSQL의 장점이기도 하고 단점이기도 한 것 같다. 정말 넣는대로 다 들어가기 때문에 생각을 많이 하고 꺼내기 쉬운 모양으로 데이터를 잘 정해서 넣는게 중요하다.*


### 5. 종류 

NoSQL 데이터베이스는 크게 네 가지 모델로 나눌 수 있다.

- Key-value
- Document
- Column-family
- Graph

이 중 그래프 모델을 제외한 나머지 세 모델은 집합-지향(Aggregate-oriented) 모델이다.

#### 5.1. 집합-지향 (Aggregate-oriented) 모델

집합(Aggregate)이란 연산의 한 단위로 취급되는 연관된 객체들의 집합이다. 집합-지향 데이터베이스는 집합 자료구조로 이루어져 있다. 관계형 모델처럼 하나의 엔티티에 대한 ACID 트랜잭션을 지원하지는 않지만, 하나의 집합에 대한 연산에서는 트랜잭션을 지원한다.

집합-지향 데이터베이스는 여러 대의 클러스터로 이루어진 시스템에서 사용하기 적합하다. 다시 말해 수평적 확장이 용이하다는 것이다. 이는 관계형 데이터베이스와는 달리 연관된 데이터들이 함께 움직이기 때문이다. 또한 메모리 내의 자료구조와 집합 간 데이터가 잘 일치하므로, 관계형 데이터베이스처럼 객체-관계 매핑 프레임워크가 필요하지 않다. 데이터의 검색도 아주 쉬운 편으로, 키나 ID를 사용하면 쉽게 집합 레코드를 찾아낼 수 있다.

**5.1.1 key-value**  

키 값(Key-value) 저장소는 가장 단순한 형태의 NoSQL으로, 수평적 확장이 용이하다. 또한 아주 간단한 API만을 제공하기 때문에 배우는 것이 어렵지 않다. 하지만 값의 내용을 사용한 쿼리가 불가능하다는 단점이 있다. 사용자는 키를 사용해 값을 읽어들인 뒤, 어플리케이션 레벨에서 적절히 처리해야 한다.

키-값 저장소는 데이터가 키와 값의 쌍으로 저장된다. 키는 값에 접근하기 위한 용도로 사용되며, 값은 어떠한 형태의 데이터라도 담을 수 있다. 심지어는 이미지나 비디오도 가능하다. 또한 간단한 API를 제공하는 만큼 질의의 속도가 굉장히 빠른 편이다. 

Key-value 모델을 사용하는 NoSQL 데이터베이스로는 Memcached, Riak, Redis, Amazon Dynamo DB 등이 있다.

*Key-value형태의 모델은 그냥 프로그래밍을 할 때 자주 사용하는 Map이라는 개념이 서버에 올라가있는 거라고 생각해도 무방할 것 같다. 사용또한 매우 간단하게 할 수 있다. 여기서 주목해야 될 점은 다양한 DB중에 어떤 DB를 쓸 것이냐에 대한 고민이 필요하다는 점인 것 같다.*


**5.1.2. Document**

키-값 모델에서 한층 진화한 모델로 생각할 수 있다. 데이터는 키와 도큐먼트(Document)의 형태로 저장된다. 키-값 모델과 다른 점이라면 Value가 계층적인 형태인 도큐먼트로 저장된다는 것이다. 객체지향에서의 객체와 유사하며, 이들은 하나의 단위로 취급되어 저장된다. 다시 말해 하나의 객체를 여러 개의 테이블에 나눠 저장할 필요가 없어진다는 뜻이다. 또한 Document 모델에서는 **도큐먼트 내의 item을 이용한 쿼리가 가능**하다. 다만 이를 위해서는 Xquery나 다른 도큐먼트 질의 언어가 필요하다.

주요한 특징으로는 객체-관계 매핑이 필요하지 않다. 객체를 도큐먼트의 형태로 바로 저장 가능하기 때문이다. 또한 검색에 최적화되어 있는데, 이는 키-값 모델의 특징과 동일하다. 단점이라면 사용이 번거롭고 쿼리가 SQL과는 다르다는 점이다. 도큐먼트 모델에서는 질의의 결과가 JSON이나 xml 형태로 출력되기 때문에 그 사용 방법이 RDBMS에서의 질의 결과를 사용하는 방법과 다르다. 또한 질의 언어가 SQL과 다르기 때문에 사용에 익숙해지기까지 다소 어려움이 있을 수 있다.

Document 모델을 사용하는 NoSQL 데이터베이스로는 MongoDB,CouchDB, MarkLogic 등이 있다.

*드디어 필자가 사용해 봤던 유일한 NoSQL인 몽고DB가 등장을 했다. 현업에 와서 사용해보려 하니 데이터를 입력할 때는 문제가 별로 되지 않지만, 데이터를 가지고 오려 할 때에는 많은 문제가 생긴다는 얘기를 접하게 되었다. 이에 대해서는 이 이후 포스팅에서 한번 자세히 알아보도록 하겠다.*

**5.1.3. Column-Family**

컬럼-패밀리(Column-family) 모델은 위의 두 모델과는 다소 차이가 있지만 집합-지향 모델로 간주된다. 이전의 모델들이 키-값 쌍 중 값을 이용해 필드를 결정했다면, 특이하게도 이 모델은 키에서 필드를 결정한다. 키는 Row(키 값)와 Column-family, Column-name을 가진다. 연관된 데이터들은 같은 Column-family 안에 속해 있으며, 각자의 Column-name을 가진다. 관계형 모델로 설명하자면 어트리뷰트가 계층적인 구조를 가지고 있는 셈이다. 이렇게 저장된 데이터는 하나의 커다란 테이블로 표현이 가능하며, 질의는 Row, Column-family, Column-name을 통해 수행된다.

이러한 특징 덕에 컬럼-패밀리 모델은 클러스터링이 쉽게 이뤄지며, Time stamp가 존재해 값이 수정된 히스토리를 알 수 있다. 또한 값들은 일련의 바이너리 데이터로 존재하기 때문에 어떤 형태의 데이터라도 저장될 수 있다.

다만 위의 두 모델들과는 다르게 Blob 단위의 쿼리가 불가능하며, Row와 Column의 초기 디자인이 중요하다. Schema-less이긴 하지만 새로운 필드를 만드는 데 드는 비용이 크기 때문에 사실상 결정된 스키마를 변경하는 것이 어렵다.

Column-family 모델을 사용하는 NoSQL 데이터베이스로는 HBase, Cassandra, Hypertable 등이 있다.

*이놈은 도대체 뭘 하는 놈일까? 어떤 상황에서 쓰일지가 전혀 감이 오지 않는다. 뭔가 NoSQL과 RDBMS의 중간 어디쯤에 있는 것 같은데, 스키마 프리한 NoSQL의 특성이 거의 사라지게 된다면 과연 쓰게 될 일이 있을지가 의문이 생긴다.*

##마무으리 

여기까지 이번 포스팅에서는 NoSQL의 대표적인 특징들과 어떤 상황에서 써야 할지에 대한 감을 잡는 정도로 포스팅을 하였다. 사실 나무 위키에 있는 글을 그대로 가져와 필자가 읽어보고 감상을 적는 정도에 끝났지만, 개인적으로는 정말 공부가 많이 된 포스팅이었던 것 같다. 

모호하게 가지고 있던 NoSQL에 대한 개념과 특징적인 것들을 학습 할 수 있었고, 앞으로 DB를 선택할 때 RDBMS인지 NoSQL에 대한 선택을 할 때 좀 더 논리적 근거에 기반해서 선택을 할 수 있는 기반을 만든 것 같다.

결론적으로 NoSQL은 Scale-up이 아닌 Scale-out을 목적으로 만들어졌으며, 이는 개발 시 드는 비용때문이라고 볼 수 있다. NoSQL을 쓰게되는 또 하나의 이유는 간편하게 사용할 수 있기 때문이 아닐까 라는 생각도 들게 되었다. 데이터를 가공해서 꺼낸다거나 하는일은 잘 하지는 못하지만, 넣은 그대로 꺼내서 어플리케이션 혹은 서버단에서 가공을 해서 쓸 생각을 하고 코드를 작성한다면, 정말 간편하게 코드를 작성해서 사용 할 수 있을 것 같다. 

이 다음 포스팅들에서는 NoSQL중 대중적으로 알려진 MongoDB, Redis, DyanmoDB등에 대한 공부를 해보려 한다. 주로 성능관점에서 살펴보게 될 것 같으며 이를 통해 NoSQL중에서는 어떤 DB를 선택하여 사용하는 것이 효율적인지에 대한 얘기를 해보려한다. 

뿅!

[^1]: http://www.slideshare.net/kidoki/nosql-2-17530979
