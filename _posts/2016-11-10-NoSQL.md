---
layout: post
title: Database 종류와 분석 - NoSQL

---

# NoSQL

이번 포스트에서는 NoSQL에 대한 탐험을 시작해보도록 하겠다. NoSQL 이놈은 대체 뭐길래 뜬금없이 등장해서 프로그래머들을 괴롭히는 것일까? 필자가 처음 프로그래밍을 시작할 때즈음 (2014년정도) 부터 소문이 돌기 시작하더니 이제는 너무나 많이들 사용하는 대중적인 데이터베이스 포맷이 되어버렸다. 

필자가 처음 NoSQL로 접했던 DB는 MongoDB였다. Node.js를 필두로 한 MEAN스택에서부터 스멀스멀 보이기 시작하더니 나중에 가서는 한번쯤은 다들 써본? 그런 존재가 되어있었다. 

![](https://i.ytimg.com/vi/Jh0er2pRcq8/maxresdefault.jpg =600x)

필자가 한번 써볼까? 라는 생각이 들었던 것은 그 때 즈음이었던 것 같다. 사실상 안드로이드 공부에만 집중하고 있었던 나에게는 MEAN스택 자체가 '아 웹쪽 세상에서 일어나는 무언가인가보다' 정도로만 생각되고 그렇게 큰 관심을 두고 있지 않았던 것이 사실이었다.

하지만 역시 호기심이 드는 것은 어쩔 수 없었던것 같다. 안드로이드 개발을 하면서 서버 개발도 같이 해야되는 상황이 생겼었고 기억 저 한켠에 묻어두었던 MEAN스택을 꺼내들었다. 처음에는 Node.js만 공부해 볼 생각으로 접하게 되었고, 하다보니 아 그러면 NoSQL인 MongoDB도 한번 써볼까? 라는 생각까지 미치게 되었다. 

간단한 API서버만 만들면 되는 상황이었고 JSON 형식으로 통신을 할 생각을 하고 있었기 때문에 NoSQL이 JSON데이터를 날로 저장하고 꺼낼 수 있다는 지식 하나만으로 '한번 해보자'라는 생각을 하게 되었던 것 같다. 

하지만 점차 써감에 있어서 여러 문제들이 (예를 들면 데이터 두개를 섞어서 가져오고 싶다던가) 발생하게 되었고, RDBMS에 너무 익숙해져 있던 것일까 NoSQL의 사용을 포기하는 시점에 다다르게 되었었다.

그 이후로 NoSQL과는 인연을 끊고 살다가 이제 회사에 들어와 어쩔 수 없이 이 친구를 마주봐야 하는 상황에 처하게 되었다. 이왕 이렇게 된거 제대로 알아보고 써보자는 생각이 들었고 앞으로 이 포스팅을 통해서 제!대!로!(제발...) NoSQL의 종류와 특징을 알아보도록 하겠다. 

## NoSQL이란?
나무 위키에 매우 자세하고 이해하기 쉽게 정리되어 있기에 그대로 들고와 필자의 사견을 살짝만 첨가하도록 하겠다. 

[https://namu.wiki/w/NoSQL](https://namu.wiki/w/NoSQL)

### 1. 개요

단어 뜻 그 자체를 따지자면 "Not only SQL"로, SQL만을 사용하지 않는 데이터베이스 관리 시스템(DBMS)을 지칭하는 단어이다. 관계형 데이터베이스를 사용하지 않는다는 의미가 아닌, 여러 유형의 데이터베이스를 사용하는 것이다.

데이터를 조직하는 방법에는 리스트, 해시, 트리, 그래프 등의 다양한 방법이 있고 각각은 장점과 단점이 명확하기 때문에 단순히 NoSQL 이라고만 해서는 너무 뜬구름 잡는 얘기가 된다. 저 단어는 RDBMS가 데이터베이스의 거의 전부를 차지할 정도로 독점적인 지위를 차지하고 있는 현재 상황에 반발하는 정신을 담고 있다.

*지금까지 필자는 NoSQL이라고 하면 뭔가 자유롭게 데이터를 저장하고 Json이거나 문자열이거나 넣고싶은 모양 '그대로' 넣었다가 '그대로' 꺼내서 사용하는 형태를 생각했었다. 아래에서도 나오겠지만 이런 생각은 틀린 생각이었다는 것을 알게되었다. 이제는 NoSQL은 RDBMS와 같이 어떠한 형태를 딱 지정해서 말하는 것이 아니라 RDBMS가 아닌 모든 것을 총칭해 말하는 것이라고 느껴진다.*

### 2. 정의 

“Not Only SQL” : 데이터를 저장하는 데에는 SQL 외에 다른 방법들도 있다.

NoSQL이라고 하는 말은 No 'English' 라고 하는 말과 마찬가지다. 세상에는 영어 말고도 수많은 언어가 존재한다. MongoDB에서 사용하는 쿼리 언어와 CouchDB에서 사용하는 쿼리 언어는 서로 전혀 다르다. 그럼에도 이 두 쿼리 언어는 같은 NoSQL 카테고리에 속한다. 어쨌거나 SQL이 아니기 때문이다. 또한 NoSQL이 No RDBMS를 의미하지는 않는다. BerkleyDB같은 예외가 있기 때문이다. 그리고 No RDMBS가 NoSQL인 것도 아니다. SQL호환 레이어를 제공하는 KV-store라는 예외가 역시 존재한다. 물론 KV-store의 특징상 range query를 where절에 넣을 수 없으므로 완전한 SQL은 못 되고 SQL의 부분집합 정도를 제공한다.

사실 아직까지 NoSQL에 내려진 **구체적인 정의는 없다**. 하지만 NoSQL이라 불리는 데이터베이스들은 대체로 다음과 같은 공통적인 성향을 보인다.

- 대부분 클러스터에서 실행할 목적으로 만들어졌기 때문에 **관계형 모델을 사용하지 않는다.** 그러나 모든 NoSQL 데이터베이스가 클러스터에서 실행되도록 맞춰진 것은 아니다. 예를 들어 NoSQL 데이터 모델 중 하나인 그래프 데이터베이스는 관계형 데이터베이스와 비슷한 분산 모델을 사용한다.
- **오픈 소스**이다. 비오픈 소스 프로젝트도 있긴 하지만, 대부분 그렇다.
- 보통 21세기 초반 웹 환경의 필요에 기초를 두고 있어서, 이 시기에 개발된 시스템만을 NoSQL이라고 부른다. 따라서 그 이전에 만들어진 ODBMS(Objective Database Management System)은 NoSQL에 해당하지 않는다.
- **스키마 없이 동작**하며, 구조에 대한 정의를 변경할 필요 없이 데이터베이스 레코드에 자유롭게 필드를 추가할 수 있다.  

````
요약 : 대부분이 오픈 소스고, 21세기 초반에 개발되었으며
SQL을 사용하지 않는 Schema-less 데이터베이스.
````

### 3. 등장 배경 

지난 20년간, 데이터를 저장하는 데에는 관계형 데이터베이스가 사용되었다. **트랜잭션을 통한 안정적인 데이터 관리**가 가장 중요한 이슈였기 때문이다. 하지만 웹 2.0 환경과 빅데이터가 등장하면서 RDBMS는 난관에 부딪히게 되었는데, 바로 *‘데이터를 처리하는 데 필요한 비용의 증가’*때문이다. 데이터와 트래픽의 양이 기하급수적으로 증가함에 따라 한 대에서 실행되도록 설계된 관계형 데이터베이스를 사용하는 것은 하드웨어적으로 큰 비용이 들게 되었다. 장비의 성능이 좋을수록, 성능을 향상시키는 데(Scale-up : 수직적 확장) 비용이 기하급수적으로 증가하기 때문이다.

NoSQL은 데이터의 일관성을 약간 포기한 대신 여러 대의 컴퓨터에 데이터를 분산하여 저장하는 것**(Scale-out : 수평적 확장)**을 목표로 등장하였다. NoSQL의 등장으로 작고 값싼 장비 여러 대로 대량의 데이터와 컴퓨팅 부하를 처리하는 것이 가능하게 되었다.

*결국 모든것은 비용으로 귀결되는것 같다. 프로그래밍이야 말로 비용을 줄이기 위한 노력의 결정체이지 않을까?*  
*처음 NoSQL에 대한 얘기를 들었을 때도 NoSQL은 데이터를 txt처럼 저장하기 떄문에 여러개의 컴퓨터에 나누어 저장해도 되는 느낌이라고 들었던 것 같다. 지금 생각해보면 정확히 그런 느낌은 아니겠지만, 그래도 어떤 말을 하려 했는지 조금은 이해가 가는 것 같다.*

### 4. 특징 

#### 4.1. 일관성과 확장성 사이의 Trade-off

일관성(Consistency)이 데이터베이스의 절대적인 요소가 아님을 주장하는 움직임이 생기기 시작했다. 이들은 비일관성이 다음과 같은 두 가지 이유로 감수할 만한 것이라고 주장했다.

- 다수가 동시에 읽고 쓰는(Read and write) 상황에서의 성능 향상을 위해서.
- 분산 환경에서 노드들이 잘 작동하고 있음에도, 시스템의 일부가 고장나면 데이터베이스를 사용할 수 없게 되는 문제를 해결하기 위해서.

*분산 환경의 얘기는 어떤 얘기인지 알 것 같은데 다수가 동시에 읽고 쓰는 것은 어떤 연관성이 있는지 헤깔린다. 추측을 해보자면 여러개의 파일로 데이터베이스를 관리하기 때문에 각 유저가 각각의 파일들을 잡고 여러개의 DB를 사용하는 느낌으로 쓴다는 것이 아닐까 싶다. 이는 아마 각각의 NoSQL의 종류에 따라서 다르지 않을까 라는 생각이 든다.* 

#### 4.2. 분산 저장

데이터와 트래픽이 증가함에 따라 기존의 장비로는 원할한 데이터의 처리가 어려워졌다. 이를 해결하기 위한 방법으로는 처리하는 장비의 성능을 키우는 **수직적 확장(Scale-up)**과 처리하는 장비의 수를 늘리는 **수평적 확장(Scale-out)**이 있다. 위에서 서술했듯이 수직적 확장은 비용적인 문제가 발생하므로 수평적 확장을 통해 성능을 올려야 한다. 하지만 문제는 관계형 데이터베이스가 클러스터 상에서 효율적으로 동작하도록 설계되지 않았다는 점이다. 

물론 관계형 데이터베이스를 클러스터 상에서 돌리지 못하는 것은 아니다. 클러스터 상에서 동작하는 관계형 데이터베이스 솔루션도 존재한다. 이러한 데이터베이스에서는 클러스터를 인식할 수 있는 파일 시스템을 사용해 고가용성 디스크 서브시스템에 데이터를 기록하는 공유 디스크 개념을 사용한다. 하지만 클러스터의 디스크 서브시스템이 단일 고장점이 되어, 디스크 서브시스템에 문제가 생길 경우 데이터베이스를 사용할 수 없게 된다.

샤딩(Sharding)은 샤드 키(Shard key)를 기준으로 하나의 테이블을 수평 분할하여 서로 다른 클러스터에 분산 저장하고 질의할 수 있는 기법이다. 이를 통해 관계형 데이터베이스에서도 부하를 분산할 수 있지만 어플리케이션 레벨에서 모든 샤딩을 제어해야 한다. (어떤 데이터를 어느 클러스터에서 처리해야 하는지 등) 또한 여러 샤드에 걸치는 쿼리나 참조 정합성, 트랜잭션, 일관성의 제어에 문제가 발생한다.

분산 저장을 지원하는 NoSQL 데이터베이스의 경우, **집합-지향(Aggregate-oriented) 모델**[^1]을 사용하여 이러한 문제를 해결한다. 연관된 데이터들이 함께 분산되므로, 관계형 모델에서처럼 복잡한 제어가 필요하지 않게 된다.


*결국 분산 저장을 하는 이유는 DB를 1개만 만들어두면 성능에 문제가 있기 때문이 아닐까 싶다. 많은 데이터를 저장해야 된다면 분산하여 저장하는 것도 나쁘지 않을 것으로 보인다. 반대로 데이터가 많지 않다면 굳이 분산저장을 안해도 된다고 느껴진다.*




[^1]: http://www.slideshare.net/kidoki/nosql-2-17530979